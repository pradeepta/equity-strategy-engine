// Prisma Schema for Trading Strategy Management System
// PostgreSQL database with comprehensive strategy versioning, execution tracking, and order management

generator client {
  provider = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// USER & ACCOUNT MANAGEMENT (Multi-tenant support)
// ============================================================================

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  name              String?
  role              UserRole   @default(TRADER)

  // Relationships
  strategies        Strategy[]
  accounts          Account[]
  apiKeys           ApiKey[]

  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@index([email])
  @@map("users")
}

enum UserRole {
  ADMIN
  TRADER
  VIEWER
}

model Account {
  id                String     @id @default(cuid())
  userId            String

  // Broker account details
  broker            String     // 'tws' or 'alpaca'
  accountId         String     // TWS: DU9999999, Alpaca: account ID
  accountName       String?

  // Configuration
  isActive          Boolean    @default(true)
  isPaper           Boolean    @default(true)
  maxConcurrentStrategies Int  @default(10)

  // Relationships
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategies        Strategy[]

  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@unique([userId, broker, accountId])
  @@index([userId])
  @@index([isActive])
  @@map("accounts")
}

model ApiKey {
  id                String     @id @default(cuid())
  userId            String

  name              String
  keyHash           String     // Hashed API key
  lastUsed          DateTime?
  expiresAt         DateTime?
  isActive          Boolean    @default(true)

  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@index([userId])
  @@index([isActive])
  @@map("api_keys")
}

// ============================================================================
// STRATEGY MANAGEMENT
// ============================================================================

model Strategy {
  id                String            @id @default(cuid())
  userId            String
  accountId         String?

  // Identity
  symbol            String
  name              String
  timeframe         String

  // Current YAML content (active version)
  yamlContent       String            @db.Text

  // Status
  status            StrategyStatus    @default(DRAFT)

  // Metadata extracted from YAML
  description       String?           @db.Text
  riskPerTrade      Float?
  entryTimeoutBars  Int?
  rthOnly           Boolean?

  // Lifecycle timestamps
  activatedAt       DateTime?
  closedAt          DateTime?
  archivedAt        DateTime?

  // Close reason (for auditing)
  closeReason       String?           @db.Text

  // Soft delete
  deletedAt         DateTime?

  // Relationships
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  account           Account?          @relation(fields: [accountId], references: [id], onDelete: SetNull)
  versions          StrategyVersion[]
  executions        StrategyExecution[]
  orders            Order[]
  evaluations       StrategyEvaluation[]

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([userId, symbol, status, deletedAt])  // One active strategy per symbol per user
  @@index([userId, status])
  @@index([symbol])
  @@index([status])
  @@index([userId, accountId])
  @@map("strategies")
}

enum StrategyStatus {
  DRAFT          // Created but not yet activated
  PENDING        // Ready to be loaded by orchestrator
  ACTIVE         // Currently running
  CLOSED         // Stopped by evaluator or user
  ARCHIVED       // Invalid or deprecated
  FAILED         // Compilation/validation failed
}

// ============================================================================
// STRATEGY VERSIONING (Rollback support)
// ============================================================================

model StrategyVersion {
  id                String            @id @default(cuid())
  strategyId        String

  // Version tracking
  versionNumber     Int               // Auto-incremented per strategy
  yamlContent       String            @db.Text

  // Metadata snapshot at this version
  name              String
  timeframe         String
  description       String?           @db.Text

  // Change tracking
  changeReason      String?           @db.Text
  changedBy         String?           // User or system
  changeType        VersionChangeType

  // Validation
  isValid           Boolean           @default(true)
  compilationError  String?           @db.Text

  // Relationships
  strategy          Strategy          @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  createdAt         DateTime          @default(now())

  @@unique([strategyId, versionNumber])
  @@index([strategyId])
  @@index([createdAt])
  @@map("strategy_versions")
}

enum VersionChangeType {
  CREATED         // Initial version
  MANUAL_EDIT     // User edited
  AUTO_SWAP       // Evaluator swap
  ROLLBACK        // Rollback to previous version
  IMPORTED        // Imported from file
}

// ============================================================================
// EXECUTION HISTORY (Swap & Evaluation Tracking)
// ============================================================================

model StrategyExecution {
  id                String            @id @default(cuid())
  strategyId        String

  // Execution event
  eventType         ExecutionEventType

  // Context
  currentState      String?           // IDLE, ARMED, TRIGGERED, MANAGING
  barsProcessed     Int?
  openOrderCount    Int?

  // Swap details (if eventType = SWAP)
  oldVersionId      String?
  newVersionId      String?
  swapReason        String?           @db.Text

  // Bar data snapshot
  currentPrice      Float?
  currentVolume     BigInt?
  barTimestamp      DateTime?

  // Metadata
  metadata          Json?             // Flexible JSON for additional context

  // Operation tracking (Phase 4)
  operationId       String?           // Links to OperationQueue for idempotency
  initiatedBy       String?           // User ID or 'system'
  completedAt       DateTime?

  // Relationships
  strategy          Strategy          @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  createdAt         DateTime          @default(now())

  @@index([strategyId])
  @@index([eventType])
  @@index([createdAt])
  @@index([operationId])
  @@map("strategy_executions")
}

enum ExecutionEventType {
  ACTIVATED       // Strategy activated
  DEACTIVATED     // Strategy stopped
  SWAP            // Strategy swapped
  BAR_PROCESSED   // Bar processed (can log periodically)
  ERROR           // Execution error
  INVALIDATED     // Rule invalidation triggered
}

model StrategyEvaluation {
  id                String            @id @default(cuid())
  strategyId        String

  // Evaluation request snapshot
  portfolioValue    Float?
  unrealizedPnL     Float?
  realizedPnL       Float?

  currentBar        Json?             // Bar data
  recentBars        Json?             // Recent bars for context

  // Evaluation response
  recommendation    EvaluationRecommendation
  confidence        Float             // 0-1
  reason            String            @db.Text

  // Suggested strategy (if swap recommended)
  suggestedYaml     String?           @db.Text
  suggestedName     String?
  suggestedReasoning String?          @db.Text

  // Action taken
  actionTaken       Boolean           @default(false)
  actionResult      String?           @db.Text

  // Relationships
  strategy          Strategy          @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  createdAt         DateTime          @default(now())

  @@index([strategyId])
  @@index([recommendation])
  @@index([createdAt])
  @@map("strategy_evaluations")
}

enum EvaluationRecommendation {
  KEEP
  SWAP
  CLOSE
}

// ============================================================================
// ORDER & TRADE TRACKING
// ============================================================================

model Order {
  id                String            @id @default(cuid())
  strategyId        String

  // Order identity
  brokerOrderId     String?           // ID from broker (TWS/Alpaca)
  planId            String            // From YAML orderPlans
  symbol            String

  // Order details
  side              OrderSide
  qty               Int
  type              OrderType
  limitPrice        Float?
  stopPrice         Float?

  // Bracket order relationships
  parentOrderId     String?           // For stop/target orders
  isParent          Boolean           @default(false)

  // Status
  status            OrderStatus       @default(PENDING)
  filledQty         Int               @default(0)
  avgFillPrice      Float?

  // Timing
  submittedAt       DateTime?
  filledAt          DateTime?
  cancelledAt       DateTime?

  // Error tracking
  errorMessage      String?           @db.Text

  // Relationships
  strategy          Strategy          @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  parentOrder       Order?            @relation("OrderHierarchy", fields: [parentOrderId], references: [id], onDelete: Cascade)
  childOrders       Order[]           @relation("OrderHierarchy")
  fills             Fill[]

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@index([strategyId])
  @@index([brokerOrderId])
  @@index([symbol])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
}

enum OrderStatus {
  PENDING
  SUBMITTED
  FILLED
  PARTIALLY_FILLED
  CANCELLED
  REJECTED
}

model Fill {
  id                String            @id @default(cuid())
  orderId           String

  // Fill details
  qty               Int
  price             Float
  commission        Float?

  // Timing
  filledAt          DateTime

  // Relationships
  order             Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt         DateTime          @default(now())

  @@index([orderId])
  @@index([filledAt])
  @@map("fills")
}

// ============================================================================
// PERFORMANCE ANALYTICS (Trade P&L)
// ============================================================================

model Trade {
  id                String            @id @default(cuid())
  strategyId        String
  symbol            String

  // Entry
  entryOrderId      String            @unique
  entryQty          Int
  entryPrice        Float
  entryTime         DateTime

  // Exit
  exitOrderId       String?           @unique
  exitQty           Int?
  exitPrice         Float?
  exitTime          DateTime?

  // P&L
  realizedPnL       Float?
  commission        Float?
  netPnL            Float?

  // Classification
  tradeType         TradeType?
  isWin             Boolean?

  // Note: No FK to Strategy to preserve history even if strategy deleted

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@index([strategyId])
  @@index([symbol])
  @@index([entryTime])
  @@index([exitTime])
  @@map("trades")
}

enum TradeType {
  FULL_EXIT
  PARTIAL_EXIT
  STOP_LOSS
  TARGET_HIT
}

// ============================================================================
// SYSTEM LOGS (Optional: for debugging)
// ============================================================================

model SystemLog {
  id                String            @id @default(cuid())

  level             LogLevel
  component         String            // FilesystemWatcher, StrategyLifecycleManager, etc.
  message           String            @db.Text
  metadata          Json?

  createdAt         DateTime          @default(now())

  @@index([level])
  @@index([component])
  @@index([createdAt])
  @@map("system_logs")
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

// ============================================================================
// OPERATION QUEUE & IDEMPOTENCY (Phase 2)
// ============================================================================

model OperationQueue {
  id              String            @id @default(cuid())
  operationId     String            @unique  // UUID for idempotency
  operationType   OperationType
  targetSymbol    String?
  strategyId      String?
  status          OperationStatus
  priority        Int               @default(0)
  retryCount      Int               @default(0)
  maxRetries      Int               @default(3)
  lockedUntil     DateTime?
  lockedBy        String?           // Process ID holding lock
  payload         Json              // Operation parameters
  result          Json?             // Result for idempotent replay
  errorMessage    String?           @db.Text
  createdAt       DateTime          @default(now())
  startedAt       DateTime?
  completedAt     DateTime?

  @@index([status, priority, createdAt])
  @@index([operationId])
  @@index([targetSymbol, status])
  @@map("operation_queue")
}

enum OperationType {
  SWAP_STRATEGY
  CANCEL_ORDERS
  SUBMIT_ORDERS
  EVALUATE_STRATEGY
  CLOSE_STRATEGY
  RECONCILE_ORDERS
}

enum OperationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================================================
// ORDER AUDIT LOG (Phase 4)
// ============================================================================

model OrderAuditLog {
  id              String            @id @default(cuid())
  orderId         String?
  brokerOrderId   String?
  strategyId      String
  eventType       OrderEventType
  oldStatus       OrderStatus?
  newStatus       OrderStatus?
  quantity        Float?
  price           Float?
  errorMessage    String?           @db.Text
  metadata        Json?
  createdAt       DateTime          @default(now())

  @@index([orderId, createdAt])
  @@index([brokerOrderId, createdAt])
  @@index([strategyId, createdAt])
  @@index([eventType])
  @@map("order_audit_log")
}

enum OrderEventType {
  SUBMITTED
  CANCELLED
  FILLED
  PARTIALLY_FILLED
  REJECTED
  RECONCILED
  ORPHANED
  MISSING
}
